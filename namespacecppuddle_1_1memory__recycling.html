<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPPuddle: cppuddle::memory_recycling Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CPPuddle
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecppuddle.html">cppuddle</a></li><li class="navelem"><a class="el" href="namespacecppuddle_1_1memory__recycling.html">memory_recycling</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cppuddle::memory_recycling Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>CPPuddle namespace containing the memory recycling functionality.  
<a href="namespacecppuddle_1_1memory__recycling.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecppuddle_1_1memory__recycling_1_1detail" id="r_namespacecppuddle_1_1memory__recycling_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppuddle_1_1memory__recycling_1_1device__selection" id="r_namespacecppuddle_1_1memory__recycling_1_1device__selection"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling_1_1device__selection.html">device_selection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppuddle_1_1memory__recycling_1_1aggregated__recycling__view.html">aggregated_recycling_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppuddle_1_1memory__recycling_1_1cuda__aggregated__device__buffer.html">cuda_aggregated_device_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for CUDA device memory using a passed aggregated allocator (which ideally should be an allocator_slice from the work aggregation)  <a href="structcppuddle_1_1memory__recycling_1_1cuda__aggregated__device__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppuddle_1_1memory__recycling_1_1cuda__device__buffer.html">cuda_device_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for CUDA device memory (ideally used with a recycling allocator)  <a href="structcppuddle_1_1memory__recycling_1_1cuda__device__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppuddle_1_1memory__recycling_1_1hip__aggregated__device__buffer.html">hip_aggregated_device_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppuddle_1_1memory__recycling_1_1hip__device__buffer.html">hip_device_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppuddle_1_1memory__recycling_1_1recycling__view.html">recycling_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppuddle_1_1memory__recycling_1_1view__deleter.html">view_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afd4fac9d8aca86f12f9d08a860690eff" id="r_afd4fac9d8aca86f12f9d08a860690eff"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t alignement, std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afd4fac9d8aca86f12f9d08a860690eff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#afd4fac9d8aca86f12f9d08a860690eff">recycle_aligned</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, boost::alignment::aligned_allocator&lt; T, alignement &gt; &gt;</td></tr>
<tr class="memdesc:afd4fac9d8aca86f12f9d08a860690eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for boost aligned memory.  <br /></td></tr>
<tr class="separator:afd4fac9d8aca86f12f9d08a860690eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ed206768183735f03b1123460434a5" id="r_aa3ed206768183735f03b1123460434a5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t alignement, std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa3ed206768183735f03b1123460434a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#aa3ed206768183735f03b1123460434a5">aggressive_recycle_aligned</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, boost::alignment::aligned_allocator&lt; T, alignement &gt; &gt;</td></tr>
<tr class="memdesc:aa3ed206768183735f03b1123460434a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for boost aligned memory (reusing previous content as well)  <br /></td></tr>
<tr class="separator:aa3ed206768183735f03b1123460434a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aae5124b7631b3fb85c9f6bc79fd7f" id="r_ad9aae5124b7631b3fb85c9f6bc79fd7f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad9aae5124b7631b3fb85c9f6bc79fd7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#ad9aae5124b7631b3fb85c9f6bc79fd7f">recycle_allocator_cuda_host</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1cuda__pinned__allocator.html">detail::cuda_pinned_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ad9aae5124b7631b3fb85c9f6bc79fd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for CUDA pinned host memory.  <br /></td></tr>
<tr class="separator:ad9aae5124b7631b3fb85c9f6bc79fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4585031469aca3059140f007e8cff8f1" id="r_a4585031469aca3059140f007e8cff8f1"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4585031469aca3059140f007e8cff8f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a4585031469aca3059140f007e8cff8f1">recycle_allocator_cuda_device</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1cuda__device__allocator.html">detail::cuda_device_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4585031469aca3059140f007e8cff8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for CUDA device memory.  <br /></td></tr>
<tr class="separator:a4585031469aca3059140f007e8cff8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3514506503f82424e8ea09dd50a0f28d" id="r_a3514506503f82424e8ea09dd50a0f28d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3514506503f82424e8ea09dd50a0f28d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a3514506503f82424e8ea09dd50a0f28d">recycle_allocator_hip_host</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1hip__pinned__allocator.html">detail::hip_pinned_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a3514506503f82424e8ea09dd50a0f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for HIP pinned host memory.  <br /></td></tr>
<tr class="separator:a3514506503f82424e8ea09dd50a0f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490d1f0f964bce01e74e9e11f20c5650" id="r_a490d1f0f964bce01e74e9e11f20c5650"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a490d1f0f964bce01e74e9e11f20c5650"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a490d1f0f964bce01e74e9e11f20c5650">recycle_allocator_hip_device</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1hip__device__allocator.html">detail::hip_device_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a490d1f0f964bce01e74e9e11f20c5650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for HIP device memory.  <br /></td></tr>
<tr class="separator:a490d1f0f964bce01e74e9e11f20c5650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89380710c83af374fc01532c8d0d5401" id="r_a89380710c83af374fc01532c8d0d5401"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a89380710c83af374fc01532c8d0d5401"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a89380710c83af374fc01532c8d0d5401">recycle_std</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, std::allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a89380710c83af374fc01532c8d0d5401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for std memory.  <br /></td></tr>
<tr class="separator:a89380710c83af374fc01532c8d0d5401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc444d6dbadf474498cd31bb4665462" id="r_a4cc444d6dbadf474498cd31bb4665462"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cc444d6dbadf474498cd31bb4665462"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a4cc444d6dbadf474498cd31bb4665462">aggressive_recycle_std</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, std::allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4cc444d6dbadf474498cd31bb4665462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for boost aligned memory (reusing previous content as well)  <br /></td></tr>
<tr class="separator:a4cc444d6dbadf474498cd31bb4665462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7fb25afa53e6962eeafb978fb8144" id="r_ac3a7fb25afa53e6962eeafb978fb8144"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac3a7fb25afa53e6962eeafb978fb8144"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#ac3a7fb25afa53e6962eeafb978fb8144">recycle_allocator_sycl_host</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1sycl__host__default__allocator.html">detail::sycl_host_default_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac3a7fb25afa53e6962eeafb978fb8144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for SYCL pinned host memory (default device)  <br /></td></tr>
<tr class="separator:ac3a7fb25afa53e6962eeafb978fb8144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d0eb765664457a9a123826c5de2e0" id="r_a2e3d0eb765664457a9a123826c5de2e0"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e3d0eb765664457a9a123826c5de2e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a2e3d0eb765664457a9a123826c5de2e0">recycle_allocator_sycl_device</a> = <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1sycl__device__default__allocator.html">detail::sycl_device_default_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a2e3d0eb765664457a9a123826c5de2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycling allocator for SYCL device memory (default device)  <br /></td></tr>
<tr class="separator:a2e3d0eb765664457a9a123826c5de2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a588b73bb5215699426f49714fac8d97e" id="r_a588b73bb5215699426f49714fac8d97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a588b73bb5215699426f49714fac8d97e">print_buffer_counters</a> ()</td></tr>
<tr class="memdesc:a588b73bb5215699426f49714fac8d97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print performance counters of all buffer managers to stdout.  <br /></td></tr>
<tr class="separator:a588b73bb5215699426f49714fac8d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e5492d8c61ac660f0943fc10e6287a" id="r_ae2e5492d8c61ac660f0943fc10e6287a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#ae2e5492d8c61ac660f0943fc10e6287a">force_buffer_cleanup</a> ()</td></tr>
<tr class="separator:ae2e5492d8c61ac660f0943fc10e6287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766581137c8135746512e41e9f51f5c8" id="r_a766581137c8135746512e41e9f51f5c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a766581137c8135746512e41e9f51f5c8">unused_buffer_cleanup</a> ()</td></tr>
<tr class="memdesc:a766581137c8135746512e41e9f51f5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all buffers currently marked as unused.  <br /></td></tr>
<tr class="separator:a766581137c8135746512e41e9f51f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109fbe22127bef72cdf5f89d87c5ec1b" id="r_a109fbe22127bef72cdf5f89d87c5ec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppuddle_1_1memory__recycling.html#a109fbe22127bef72cdf5f89d87c5ec1b">finalize</a> ()</td></tr>
<tr class="separator:a109fbe22127bef72cdf5f89d87c5ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CPPuddle namespace containing the memory recycling functionality. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa3ed206768183735f03b1123460434a5" name="aa3ed206768183735f03b1123460434a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ed206768183735f03b1123460434a5">&#9670;&#160;</a></span>aggressive_recycle_aligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t alignement, std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#aa3ed206768183735f03b1123460434a5">cppuddle::memory_recycling::aggressive_recycle_aligned</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt; T, boost::alignment::aligned_allocator&lt;T, alignement&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for boost aligned memory (reusing previous content as well) </p>

</div>
</div>
<a id="a4cc444d6dbadf474498cd31bb4665462" name="a4cc444d6dbadf474498cd31bb4665462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc444d6dbadf474498cd31bb4665462">&#9670;&#160;</a></span>aggressive_recycle_std</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a4cc444d6dbadf474498cd31bb4665462">cppuddle::memory_recycling::aggressive_recycle_std</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt;T, std::allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for boost aligned memory (reusing previous content as well) </p>

</div>
</div>
<a id="afd4fac9d8aca86f12f9d08a860690eff" name="afd4fac9d8aca86f12f9d08a860690eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4fac9d8aca86f12f9d08a860690eff">&#9670;&#160;</a></span>recycle_aligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t alignement, std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#afd4fac9d8aca86f12f9d08a860690eff">cppuddle::memory_recycling::recycle_aligned</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt; T, boost::alignment::aligned_allocator&lt;T, alignement&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for boost aligned memory. </p>

</div>
</div>
<a id="a4585031469aca3059140f007e8cff8f1" name="a4585031469aca3059140f007e8cff8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4585031469aca3059140f007e8cff8f1">&#9670;&#160;</a></span>recycle_allocator_cuda_device</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a4585031469aca3059140f007e8cff8f1">cppuddle::memory_recycling::recycle_allocator_cuda_device</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1cuda__device__allocator.html">detail::cuda_device_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for CUDA device memory. </p>

</div>
</div>
<a id="ad9aae5124b7631b3fb85c9f6bc79fd7f" name="ad9aae5124b7631b3fb85c9f6bc79fd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aae5124b7631b3fb85c9f6bc79fd7f">&#9670;&#160;</a></span>recycle_allocator_cuda_host</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#ad9aae5124b7631b3fb85c9f6bc79fd7f">cppuddle::memory_recycling::recycle_allocator_cuda_host</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1cuda__pinned__allocator.html">detail::cuda_pinned_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for CUDA pinned host memory. </p>

</div>
</div>
<a id="a490d1f0f964bce01e74e9e11f20c5650" name="a490d1f0f964bce01e74e9e11f20c5650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490d1f0f964bce01e74e9e11f20c5650">&#9670;&#160;</a></span>recycle_allocator_hip_device</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a490d1f0f964bce01e74e9e11f20c5650">cppuddle::memory_recycling::recycle_allocator_hip_device</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1hip__device__allocator.html">detail::hip_device_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for HIP device memory. </p>

</div>
</div>
<a id="a3514506503f82424e8ea09dd50a0f28d" name="a3514506503f82424e8ea09dd50a0f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3514506503f82424e8ea09dd50a0f28d">&#9670;&#160;</a></span>recycle_allocator_hip_host</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a3514506503f82424e8ea09dd50a0f28d">cppuddle::memory_recycling::recycle_allocator_hip_host</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1hip__pinned__allocator.html">detail::hip_pinned_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for HIP pinned host memory. </p>

</div>
</div>
<a id="a2e3d0eb765664457a9a123826c5de2e0" name="a2e3d0eb765664457a9a123826c5de2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3d0eb765664457a9a123826c5de2e0">&#9670;&#160;</a></span>recycle_allocator_sycl_device</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a2e3d0eb765664457a9a123826c5de2e0">cppuddle::memory_recycling::recycle_allocator_sycl_device</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1sycl__device__default__allocator.html">detail::sycl_device_default_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for SYCL device memory (default device) </p>

</div>
</div>
<a id="ac3a7fb25afa53e6962eeafb978fb8144" name="ac3a7fb25afa53e6962eeafb978fb8144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a7fb25afa53e6962eeafb978fb8144">&#9670;&#160;</a></span>recycle_allocator_sycl_host</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#ac3a7fb25afa53e6962eeafb978fb8144">cppuddle::memory_recycling::recycle_allocator_sycl_host</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1aggressive__recycle__allocator.html">detail::aggressive_recycle_allocator</a>&lt;T, <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1sycl__host__default__allocator.html">detail::sycl_host_default_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for SYCL pinned host memory (default device) </p>

</div>
</div>
<a id="a89380710c83af374fc01532c8d0d5401" name="a89380710c83af374fc01532c8d0d5401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89380710c83af374fc01532c8d0d5401">&#9670;&#160;</a></span>recycle_std</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppuddle_1_1memory__recycling.html#a89380710c83af374fc01532c8d0d5401">cppuddle::memory_recycling::recycle_std</a> = typedef <a class="el" href="structcppuddle_1_1memory__recycling_1_1detail_1_1recycle__allocator.html">detail::recycle_allocator</a>&lt;T, std::allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycling allocator for std memory. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a109fbe22127bef72cdf5f89d87c5ec1b" name="a109fbe22127bef72cdf5f89d87c5ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109fbe22127bef72cdf5f89d87c5ec1b">&#9670;&#160;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppuddle::memory_recycling::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all buffers (even ones still marked as used), delete the buffer managers and the recycler itself. Disallows further usage. </p>

</div>
</div>
<a id="ae2e5492d8c61ac660f0943fc10e6287a" name="ae2e5492d8c61ac660f0943fc10e6287a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e5492d8c61ac660f0943fc10e6287a">&#9670;&#160;</a></span>force_buffer_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppuddle::memory_recycling::force_buffer_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all buffers (even ones still marked as used), delete the buffer managers and the recycler itself </p>

</div>
</div>
<a id="a588b73bb5215699426f49714fac8d97e" name="a588b73bb5215699426f49714fac8d97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588b73bb5215699426f49714fac8d97e">&#9670;&#160;</a></span>print_buffer_counters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppuddle::memory_recycling::print_buffer_counters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print performance counters of all buffer managers to stdout. </p>

</div>
</div>
<a id="a766581137c8135746512e41e9f51f5c8" name="a766581137c8135746512e41e9f51f5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766581137c8135746512e41e9f51f5c8">&#9670;&#160;</a></span>unused_buffer_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppuddle::memory_recycling::unused_buffer_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all buffers currently marked as unused. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
